<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SAE_CLIENTGestion</title>
    <base href="/" />
    <link rel="stylesheet" href="css/bootstrap/bootstrap.min.css" />
    <link rel="stylesheet" href="css/app.css" />
    <link rel="icon" type="image/png" href="favicon.png" />
    <link href="SAE_CLIENTGestion.styles.css" rel="stylesheet" />
</head>

<body>
    <div id="app">
        <svg class="loading-progress">
            <circle r="40%" cx="50%" cy="50%" />
            <circle r="40%" cx="50%" cy="50%" />
        </svg>
        <div class="loading-progress-text"></div>
    </div>

    <div id="blazor-error-ui">
        An unhandled error has occurred.
        <a href="" class="reload">Reload</a>
        <a class="dismiss">ðŸ—™</a>
    </div>
    <script src="_framework/blazor.webassembly.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        window.initializeD3 = (element, data) => {
            // DÃ©finir les filtres pour les effets de lueur
            const svg = d3.select(element)
                .append('svg')
                .attr('width', '100%')
                .attr('height', '100%');

            // Ajouter les dÃ©finitions des filtres
            const defs = svg.append("defs");

            // Filtre pour la lueur des bÃ¢timents
            const glowFilter = defs.append("filter")
                .attr("id", "glow");

            glowFilter.append("feGaussianBlur")
                .attr("stdDeviation", "3")
                .attr("result", "coloredBlur");

            const glowMerge = glowFilter.append("feMerge");
            glowMerge.append("feMergeNode")
                .attr("in", "coloredBlur");
            glowMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");

            // Filtre pour la lueur des salles
            const roomGlow = defs.append("filter")
                .attr("id", "room-glow");

            roomGlow.append("feGaussianBlur")
                .attr("stdDeviation", "2")
                .attr("result", "coloredBlur");

            const roomGlowMerge = roomGlow.append("feMerge");
            roomGlowMerge.append("feMergeNode")
                .attr("in", "coloredBlur");
            roomGlowMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");

            // CrÃ©er un gradient pour les bÃ¢timents
            const gradient = defs.append("linearGradient")
                .attr("id", "building-gradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "100%")
                .attr("y2", "100%");

            gradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", "#0a192f");

            gradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", "#172a45");

            // CrÃ©er un groupe pour le drag
            const g = svg.append('g');

            // DÃ©finir le zoom
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);

            // Fonction pour le drag des bÃ¢timents
            const dragBuilding = d3.drag()
                .on('start', dragStarted)
                .on('drag', dragged)
                .on('end', dragEnded);

            // Dessiner une grille en arriÃ¨re-plan
            const gridSize = 50;
            const gridColor = "rgba(100, 255, 218, 0.1)";

            // Lignes horizontales
            g.selectAll(".gridLineH")
                .data(d3.range(0, 800, gridSize))
                .enter()
                .append("line")
                .attr("class", "gridLine")
                .attr("x1", 0)
                .attr("y1", d => d)
                .attr("x2", 1200)
                .attr("y2", d => d)
                .style("stroke", gridColor)
                .style("stroke-width", 0.5);

            // Lignes verticales
            g.selectAll(".gridLineV")
                .data(d3.range(0, 1200, gridSize))
                .enter()
                .append("line")
                .attr("class", "gridLine")
                .attr("x1", d => d)
                .attr("y1", 0)
                .attr("x2", d => d)
                .attr("y2", 800)
                .style("stroke", gridColor)
                .style("stroke-width", 0.5);

            // Dessiner les bÃ¢timents
            const buildings = g.selectAll('.building')
                .data(data)
                .enter()
                .append('g')
                .attr('class', 'building')
                .attr('transform', d => `translate(${d.x},${d.y})`)
                .call(dragBuilding);

            // Rectangles des bÃ¢timents
            buildings.append('rect')
                .attr('width', d => d.width)
                .attr('height', d => d.height)
                .attr('fill', 'url(#building-gradient)')
                .attr('stroke', '#64ffda')
                .attr('stroke-width', 2)
                .attr('rx', 10)
                .style('filter', 'url(#glow)')
                .style('opacity', 0.9);

            // Titres des bÃ¢timents
            buildings.append('text')
                .text(d => d.name)
                .attr('x', 10)
                .attr('y', 25)
                .attr('fill', '#64ffda')
                .attr('font-size', '16px')
                .attr('font-family', 'Arial, sans-serif')
                .style('text-shadow', '0 0 10px rgba(100, 255, 218, 0.5)');

            // Dessiner les salles pour chaque bÃ¢timent
            buildings.each(function (building) {
                const buildingGroup = d3.select(this);

                const rooms = buildingGroup.selectAll('.room')
                    .data(building.rooms)
                    .enter()
                    .append('g')
                    .attr('class', 'room')
                    .attr('transform', d => `translate(${d.x},${d.y})`);

                // Rectangles des salles
                rooms.append('rect')
                    .attr('width', d => d.width)
                    .attr('height', d => d.height)
                    .attr('fill', 'rgba(100, 255, 218, 0.1)')
                    .attr('stroke', '#64ffda')
                    .attr('stroke-width', 1)
                    .attr('rx', 5)
                    .style('filter', 'url(#room-glow)')
                    .style('opacity', 0.8);

                // Noms des salles
                rooms.append('text')
                    .text(d => `${d.name} (${d.type})`)
                    .attr('x', 5)
                    .attr('y', 15)
                    .attr('fill', '#64ffda')
                    .attr('font-size', '12px')
                    .attr('font-family', 'Arial, sans-serif')
                    .style('text-shadow', '0 0 5px rgba(100, 255, 218, 0.5)');

                // Points de connexion animÃ©s
                const connectionPoints = buildingGroup.selectAll('.connection-point')
                    .data(() => d3.range(4))
                    .enter()
                    .append('circle')
                    .attr('class', 'connection-point')
                    .attr('r', 3)
                    .attr('fill', '#64ffda')
                    .attr('cx', (d, i) => [0, building.width, building.width, 0][i])
                    .attr('cy', (d, i) => [0, 0, building.height, building.height][i])
                    .style('filter', 'url(#glow)');

                // Animation des points
                function animatePoints() {
                    connectionPoints
                        .transition()
                        .duration(2000)
                        .attr('r', 5)
                        .attr('opacity', 0.2)
                        .transition()
                        .duration(2000)
                        .attr('r', 3)
                        .attr('opacity', 1)
                        .on('end', animatePoints);
                }

                animatePoints();
            });

            function dragStarted(event, d) {
                d3.select(this)
                    .raise()
                    .classed('active', true)
                    .select('rect')
                    .style('opacity', 0.7);
            }

            function dragged(event, d) {
                d3.select(this)
                    .attr('transform', `translate(${event.x},${event.y})`);
                d.x = event.x;
                d.y = event.y;
            }

            function dragEnded(event, d) {
                d3.select(this)
                    .classed('active', false)
                    .select('rect')
                    .style('opacity', 0.9);
            }
        };
    </script>
</body>

</html>
